\hypertarget{btree_8h}{\section{include/animal/btree.h File Reference}
\label{btree_8h}\index{include/animal/btree.\+h@{include/animal/btree.\+h}}
}


definitions for binary tree data type  


{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include \char`\"{}util.\+h\char`\"{}}\\*
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structsls_b_tree}{sls\+B\+Tree}
\begin{DoxyCompactList}\small\item\em binary tree abstract data type \end{DoxyCompactList}\item 
struct \hyperlink{structsls_b_node}{sls\+B\+Node}
\begin{DoxyCompactList}\small\item\em binary tree node for use in \hyperlink{structsls_b_tree}{sls\+B\+Tree} type \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\hypertarget{btree_8h_a919e93289657d350557344dae3633d33}{typedef struct \hyperlink{structsls_b_node}{sls\+B\+Node} {\bfseries sls\+B\+Node}}\label{btree_8h_a919e93289657d350557344dae3633d33}

\item 
\hypertarget{btree_8h_a0b8026eb61f0fc55d73c35db3e399316}{typedef struct \hyperlink{structsls_b_tree}{sls\+B\+Tree} {\bfseries sls\+B\+Tree}}\label{btree_8h_a0b8026eb61f0fc55d73c35db3e399316}

\item 
typedef void $\ast$($\ast$ \hyperlink{btree_8h_a47ae84e7a836a555e08b23becda28540}{sls\+Copy\+Fn} )(void const $\ast$data)
\begin{DoxyCompactList}\small\item\em function pointer type for copying btree data \end{DoxyCompactList}\item 
typedef void($\ast$ \hyperlink{btree_8h_a6a4f6dc2b5a465792a8587270a801923}{sls\+Free\+Fn} )(void $\ast$data)
\begin{DoxyCompactList}\small\item\em function pointer type for freeing btree data \end{DoxyCompactList}\item 
\hypertarget{btree_8h_af9f71082a16e95b67fd27150641575e3}{typedef enum \hyperlink{btree_8h_af715a1a23ba83cea468722fdb0fc5eaa}{sls\+Child\+Selector} \hyperlink{btree_8h_af9f71082a16e95b67fd27150641575e3}{sls\+Child\+Selector}}\label{btree_8h_af9f71082a16e95b67fd27150641575e3}

\begin{DoxyCompactList}\small\item\em enumeration used for determining which child node to select. Usage T\+B\+D \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\hypertarget{btree_8h_af715a1a23ba83cea468722fdb0fc5eaa}{enum \hyperlink{btree_8h_af715a1a23ba83cea468722fdb0fc5eaa}{sls\+Child\+Selector} \{ {\bfseries S\+L\+S\+\_\+\+C\+H\+I\+L\+D\+\_\+\+L\+E\+F\+T}, 
{\bfseries S\+L\+S\+\_\+\+C\+H\+I\+L\+D\+\_\+\+R\+I\+G\+H\+T}
 \}}\label{btree_8h_af715a1a23ba83cea468722fdb0fc5eaa}

\begin{DoxyCompactList}\small\item\em enumeration used for determining which child node to select. Usage T\+B\+D \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structsls_b_tree}{sls\+B\+Tree} $\ast$ \hyperlink{btree_8h_a4e0889885ed3fa1e7fb068a542072a1a}{sls\+\_\+btree\+\_\+new} (\hyperlink{btree_8h_a47ae84e7a836a555e08b23becda28540}{sls\+Copy\+Fn} copy\+\_\+fn, \hyperlink{btree_8h_a6a4f6dc2b5a465792a8587270a801923}{sls\+Free\+Fn} free\+\_\+fn)
\begin{DoxyCompactList}\small\item\em creates a new binary tree \end{DoxyCompactList}\item 
void \hyperlink{btree_8h_af5bae900aae352338b3d191281337c1d}{sls\+\_\+btree\+\_\+destroy} (\hyperlink{structsls_b_tree}{sls\+B\+Tree} $\ast$tree)
\begin{DoxyCompactList}\small\item\em destroys a binary tree and all nodes it contains \end{DoxyCompactList}\item 
\hyperlink{structsls_b_node}{sls\+B\+Node} $\ast$ \hyperlink{btree_8h_a54c0c232a6798da62bc24b1c209bcaee}{sls\+\_\+bnode\+\_\+new} (\hyperlink{structsls_b_tree}{sls\+B\+Tree} $\ast$tree, void const $\ast$val, \hyperlink{structsls_b_node}{sls\+B\+Node} $\ast$left, \hyperlink{structsls_b_node}{sls\+B\+Node} $\ast$right)
\begin{DoxyCompactList}\small\item\em creates new binary tree node \end{DoxyCompactList}\item 
void \hyperlink{btree_8h_ac22a93a3c3cb068643d79a1c87df7502}{sls\+\_\+bnode\+\_\+destroy} (\hyperlink{structsls_b_node}{sls\+B\+Node} $\ast$node)
\begin{DoxyCompactList}\small\item\em recursively destroys node and all child nodes \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
definitions for binary tree data type 

Created by Steven Shea on 3/14/15. for C\+M\+P\+S 1600, project 2 

\subsection{Typedef Documentation}
\hypertarget{btree_8h_a47ae84e7a836a555e08b23becda28540}{\index{btree.\+h@{btree.\+h}!sls\+Copy\+Fn@{sls\+Copy\+Fn}}
\index{sls\+Copy\+Fn@{sls\+Copy\+Fn}!btree.\+h@{btree.\+h}}
\subsubsection[{sls\+Copy\+Fn}]{\setlength{\rightskip}{0pt plus 5cm}typedef void$\ast$($\ast$ sls\+Copy\+Fn)(void const $\ast$data)}}\label{btree_8h_a47ae84e7a836a555e08b23becda28540}


function pointer type for copying btree data 

a function pointer taking a const void pointer and


\begin{DoxyParams}{Parameters}
{\em data} & pointer to data for copying \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
copy of input data 
\end{DoxyReturn}
\hypertarget{btree_8h_a6a4f6dc2b5a465792a8587270a801923}{\index{btree.\+h@{btree.\+h}!sls\+Free\+Fn@{sls\+Free\+Fn}}
\index{sls\+Free\+Fn@{sls\+Free\+Fn}!btree.\+h@{btree.\+h}}
\subsubsection[{sls\+Free\+Fn}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$ sls\+Free\+Fn)(void $\ast$data)}}\label{btree_8h_a6a4f6dc2b5a465792a8587270a801923}


function pointer type for freeing btree data 

takes a void pointer, to free associated memory and close files


\begin{DoxyParams}{Parameters}
{\em pointer} & to data \mbox{[}description\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{[}description\mbox{]} 
\end{DoxyReturn}


\subsection{Function Documentation}
\hypertarget{btree_8h_ac22a93a3c3cb068643d79a1c87df7502}{\index{btree.\+h@{btree.\+h}!sls\+\_\+bnode\+\_\+destroy@{sls\+\_\+bnode\+\_\+destroy}}
\index{sls\+\_\+bnode\+\_\+destroy@{sls\+\_\+bnode\+\_\+destroy}!btree.\+h@{btree.\+h}}
\subsubsection[{sls\+\_\+bnode\+\_\+destroy}]{\setlength{\rightskip}{0pt plus 5cm}void sls\+\_\+bnode\+\_\+destroy (
\begin{DoxyParamCaption}
\item[{{\bf sls\+B\+Node} $\ast$}]{node}
\end{DoxyParamCaption}
)}}\label{btree_8h_ac22a93a3c3cb068643d79a1c87df7502}


recursively destroys node and all child nodes 

if node's btree contains a free function pointer, it will call the function on each node's data field


\begin{DoxyParams}{Parameters}
{\em node} & \mbox{[}description\mbox{]} \\
\hline
\end{DoxyParams}
\hypertarget{btree_8h_a54c0c232a6798da62bc24b1c209bcaee}{\index{btree.\+h@{btree.\+h}!sls\+\_\+bnode\+\_\+new@{sls\+\_\+bnode\+\_\+new}}
\index{sls\+\_\+bnode\+\_\+new@{sls\+\_\+bnode\+\_\+new}!btree.\+h@{btree.\+h}}
\subsubsection[{sls\+\_\+bnode\+\_\+new}]{\setlength{\rightskip}{0pt plus 5cm}{\bf sls\+B\+Node}$\ast$ sls\+\_\+bnode\+\_\+new (
\begin{DoxyParamCaption}
\item[{{\bf sls\+B\+Tree} $\ast$}]{tree, }
\item[{void const $\ast$}]{val, }
\item[{{\bf sls\+B\+Node} $\ast$}]{left, }
\item[{{\bf sls\+B\+Node} $\ast$}]{right}
\end{DoxyParamCaption}
)}}\label{btree_8h_a54c0c232a6798da62bc24b1c209bcaee}


creates new binary tree node 

\mbox{[}long description\mbox{]}


\begin{DoxyParams}{Parameters}
{\em tree} & pointer to parent tree. Must not be null \\
\hline
{\em val} & pointer to value data \\
\hline
{\em left} & (nullable) pointer to left node \\
\hline
{\em right} & (nullable) pointer to right node \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{[}description\mbox{]} 
\end{DoxyReturn}
\hypertarget{btree_8h_af5bae900aae352338b3d191281337c1d}{\index{btree.\+h@{btree.\+h}!sls\+\_\+btree\+\_\+destroy@{sls\+\_\+btree\+\_\+destroy}}
\index{sls\+\_\+btree\+\_\+destroy@{sls\+\_\+btree\+\_\+destroy}!btree.\+h@{btree.\+h}}
\subsubsection[{sls\+\_\+btree\+\_\+destroy}]{\setlength{\rightskip}{0pt plus 5cm}void sls\+\_\+btree\+\_\+destroy (
\begin{DoxyParamCaption}
\item[{{\bf sls\+B\+Tree} $\ast$}]{tree}
\end{DoxyParamCaption}
)}}\label{btree_8h_af5bae900aae352338b3d191281337c1d}


destroys a binary tree and all nodes it contains 

\mbox{[}long description\mbox{]}


\begin{DoxyParams}{Parameters}
{\em tree} & \mbox{[}description\mbox{]} \\
\hline
\end{DoxyParams}
\hypertarget{btree_8h_a4e0889885ed3fa1e7fb068a542072a1a}{\index{btree.\+h@{btree.\+h}!sls\+\_\+btree\+\_\+new@{sls\+\_\+btree\+\_\+new}}
\index{sls\+\_\+btree\+\_\+new@{sls\+\_\+btree\+\_\+new}!btree.\+h@{btree.\+h}}
\subsubsection[{sls\+\_\+btree\+\_\+new}]{\setlength{\rightskip}{0pt plus 5cm}{\bf sls\+B\+Tree}$\ast$ sls\+\_\+btree\+\_\+new (
\begin{DoxyParamCaption}
\item[{{\bf sls\+Copy\+Fn}}]{copy\+\_\+fn, }
\item[{{\bf sls\+Free\+Fn}}]{free\+\_\+fn}
\end{DoxyParamCaption}
)}}\label{btree_8h_a4e0889885ed3fa1e7fb068a542072a1a}


creates a new binary tree 

\mbox{[}long description\mbox{]}


\begin{DoxyParams}{Parameters}
{\em compare\+\_\+fn} & callback for comparing values in two nodes uses same function signature as qsort \\
\hline
{\em copy\+\_\+fn} & callback for copying values \\
\hline
{\em free\+\_\+fn} & callback for freeing node values \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{[}description\mbox{]} 
\end{DoxyReturn}
